{"version":3,"sources":["canvas.ts","periodic-table.ts","atom.ts","bond.ts","math.ts","molecule.ts","simulate.ts","app.ts"],"names":[],"mappings":"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","file":"app.c982cdbe.js","sourceRoot":"..","sourcesContent":["export class Canvas {\n  canvas: HTMLCanvasElement;\n  ctx: CanvasRenderingContext2D;\n\n  constructor(id: string) {\n    this.canvas = document.getElementById(id) as HTMLCanvasElement;\n    this.canvas.width = window.innerWidth;\n    this.canvas.height = window.innerHeight;\n\n    this.ctx = this.canvas.getContext('2d');\n  }\n\n  get center(): [number, number] {\n    return [this.canvas.width / 2, this.canvas.height / 2];\n  }\n\n  animate(callback: (dt: number, cancel: () => void) => void) {\n    let lastFrame = performance.now();\n    const fn = () => {\n      const now = performance.now();\n      const dt = (now - lastFrame) / 1000;\n      lastFrame = now;\n      let cancelled = false;\n\n      this.canvas.width = this.canvas.clientWidth;\n      this.canvas.height = this.canvas.clientHeight;\n      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n      callback(dt, () => (cancelled = true));\n\n      if (!cancelled) {\n        requestAnimationFrame(fn);\n      }\n    };\n\n    requestAnimationFrame(fn);\n  }\n\n  drawCircle(position: [number, number], radius: number) {\n    this.ctx.fillStyle = 'white';\n    this.ctx.strokeStyle = 'black';\n    this.ctx.lineWidth = 2;\n    this.ctx.beginPath();\n    this.ctx.arc(...position, radius, 0, 2 * Math.PI);\n    this.ctx.fill();\n    this.ctx.stroke();\n  }\n\n  drawText(position: [number, number], text: string) {\n    this.ctx.fillStyle = 'black';\n    this.ctx.font = '20px sans-serif';\n    this.ctx.textAlign = 'center';\n    this.ctx.textBaseline = 'middle';\n    this.ctx.fillText(text, ...position);\n  }\n\n  drawLine(a: [number, number], b: [number, number]) {\n    this.ctx.strokeStyle = 'black';\n    this.ctx.lineWidth = 3;\n    this.ctx.beginPath();\n    this.ctx.moveTo(...a);\n    this.ctx.lineTo(...b);\n    this.ctx.stroke();\n  }\n\n  drawParallelLines(a: [number, number], b: [number, number], n: number = 2) {\n    this.ctx.beginPath();\n    this.ctx.moveTo(...a);\n    this.ctx.lineTo(...b);\n\n    for (let w = 3 * (2 * n - 1), black = true; w > 0; w -= 6, black = !black) {\n      this.ctx.strokeStyle = black ? 'black' : 'white';\n      this.ctx.lineWidth = w;\n      this.ctx.stroke();\n    }\n  }\n}\n","export const elements = [\n  'H',\n  'He',\n  'Li',\n  'Be',\n  'B',\n  'C',\n  'N',\n  'O',\n  'F',\n  'Ne',\n  'Na',\n  'Mg',\n  'Al',\n  'Si',\n  'P',\n  'S',\n  'Cl',\n  'Ar',\n  'K',\n  'Ca',\n];\n\nexport type ElementMap<T> = { [symbol: string]: T };\n\nexport const atomicNumbers: ElementMap<number> = {};\nfor (let i = 0; i < elements.length; i++) {\n  const element = elements[i];\n  atomicNumbers[element] = i + 1;;\n}\n\nexport const shellCapacities = [2, 8, 8, 18, 18];\n\nexport const elementInfo: ElementMap<{\n  period: number;\n  electronConfiguration: number[];\n  valenceElectrons: number;\n  requiredBonds: number;\n}> = {};\nfor (const element of elements) {\n  const atomicNumber = atomicNumbers[element];\n  const electronConfiguration: number[] = [];\n  let shellCapacity: number;\n  let electronsInShell: number;\n  let shell: number;\n  let electronsLeft: number;\n\n  for (\n    shell = 0, electronsLeft = atomicNumber;\n    electronsLeft > 0;\n    shell++\n  ) {\n    shellCapacity = shellCapacities[shell];\n    if (!shellCapacity) {\n      throw new Error(`Element ${element} too big`);\n    }\n    electronsInShell = Math.min(electronsLeft, shellCapacity);\n    electronConfiguration.push(electronsInShell);\n    electronsLeft -= electronsInShell;\n  }\n  const valenceElectrons = electronsInShell;\n\n  const requiredBonds =\n    valenceElectrons > shellCapacity / 2\n      ? shellCapacity - valenceElectrons\n      : valenceElectrons;\n\n  elementInfo[element] = {\n    period: shell + 1,\n    electronConfiguration,\n    valenceElectrons,\n    requiredBonds,\n  };\n}\n","import { Canvas } from \"./canvas\";\nimport { atomicNumbers, elementInfo } from \"./periodic-table\";\n\nexport class Atom {\n  constructor(public symbol: string, public position: [number, number]) {}\n\n  draw(canvas: Canvas) {\n    canvas.drawCircle(this.position, 20)\n    canvas.drawText(this.position, this.symbol);\n  }\n\n  get atomicNumber() {\n    return atomicNumbers[this.symbol];\n  }\n  get requiredBonds() {\n    return elementInfo[this.symbol].requiredBonds;\n  }\n}\n","import { Atom } from \"./atom\";\nimport { Canvas } from \"./canvas\";\n\nexport class Bond {\n  constructor(\n    public atom1: Atom,\n    public atom2: Atom,\n    /**\n     * The number of shared electrons\n     * eg. 2 for a double bond\n     */\n    public count: number\n  ) {}\n\n  draw(canvas: Canvas) {\n    canvas.drawParallelLines(this.atom1.position, this.atom2.position, this.count);\n  }\n}\n","export type Vec = [number, number]\n\nexport function dist(a: Vec, b: Vec): number {\n  const dx = b[0] - a[0];\n  const dy = b[1] - a[1];\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nexport function addV(a: Vec, b: Vec): Vec {\n  return [a[0] + b[0], a[1] + b[1]];\n}\n\nexport function subV(a: Vec, b: Vec): Vec {\n  return [a[0] - b[0], a[1] - b[1]];\n}\n\nexport function scaleV(s: number, v: Vec): Vec {\n  return [s * v[0], s * v[1]];\n}\n\nexport function normV(v: Vec): Vec {\n  return scaleV(1 / Math.sqrt(v[0] * v[0] + v[1] * v[1]), v);\n}\n\nexport function rightOf(a: Vec, b: Vec): boolean {\n  const dx = b[0] - a[0];\n  const dy = b[1] - a[1];\n  return dx > 0 && dx > Math.abs(dy);\n}\n\nexport function leftOf(a: Vec, b: Vec): boolean {\n  const dx = b[0] - a[0];\n  const dy = b[1] - a[1];\n  return dx < 0 && -dx > Math.abs(dy);\n}\n\nexport function below(a: Vec, b: Vec): boolean {\n  const dx = b[0] - a[0];\n  const dy = b[1] - a[1];\n  return dy > 0 && dy > Math.abs(dx);\n}\n\nexport function above(a: Vec, b: Vec): boolean {\n  const dx = b[0] - a[0];\n  const dy = b[1] - a[1];\n  return dy < 0 && -dy > Math.abs(dx);\n}\n","import { Atom } from \"./atom\";\nimport { Bond } from \"./bond\";\nimport { Canvas } from \"./canvas\";\nimport { above, below, dist, leftOf, rightOf } from \"./math\";\n\nconst hydrogenBondLength = 50;\nconst normalBondLength = 100;\n\ntype FormulaParts = (string | FormulaParts)[];\n\nexport class Molecule {\n  atoms: Atom[] = [];\n  private bonds: Bond[] = [];\n  private bondMap = new Map<Atom, Bond[]>();\n\n  static fromMolecularFormula(formula: string, center: [number, number]) {\n    const atoms = Molecule.parseFormula(formula);\n\n    const molecule = new Molecule();\n    for (const symbol of atoms) {\n      molecule.addAtom(new Atom(symbol, center));\n    }\n\n    molecule.autoBond();\n\n    return molecule;\n  }\n\n  static fromSimpleStructuralFormula(\n    formula: string,\n    center: [number, number]\n  ) {\n    const atoms = Molecule.parseFormula(formula).map(\n      (symbol) => new Atom(symbol, center)\n    );\n\n    const molecule = new Molecule();\n    const deferedBonds: [Atom, Atom][] = [];\n    let lastAtom: Atom;\n    for (const atom of atoms) {\n      molecule.addAtom(atom);\n\n      if (lastAtom?.requiredBonds > atom?.requiredBonds) {\n        deferedBonds.push([lastAtom, atom]);\n        continue;\n      }\n\n      if (lastAtom) {\n        molecule.bond(lastAtom, atom);\n      }\n      lastAtom = atom;\n    }\n    lastAtom = null;\n    for (const [a, b] of deferedBonds) {\n      if (lastAtom && molecule.totalBonds(lastAtom) < lastAtom.requiredBonds) {\n        molecule.bond(lastAtom, b);\n      } else {\n        molecule.bond(a, b);\n        lastAtom = b;\n      }\n    }\n\n    molecule.addExtraBonds();\n\n    return molecule;\n  }\n\n  static fromStructuralFormula(formula: string, center: [number, number]) {\n    const parts = this.parseFormulaParts(formula);\n    return this.fromStructuralFormulaParts(parts, center);\n  }\n\n  private static fromStructuralFormulaParts(\n    parts: string | FormulaParts,\n    center: [number, number]\n  ): Molecule {\n    if (typeof parts === 'string') {\n      return this.fromSimpleStructuralFormula(parts, center);\n    } else {\n      return parts\n        .map((part) =>\n          this.fromStructuralFormulaParts(part, [\n            center[0] * Math.random(),\n            center[1] * Math.random(),\n          ])\n        )\n        .reduce((a, b) => a.join(b));\n    }\n  }\n\n  join(other: Molecule): Molecule {\n    const atom1 = this.freeAtom;\n    const atom2 = other.freeAtom;\n    this.merge(other);\n    this.bond(atom1, atom2);\n    return this;\n  }\n\n  get freeAtom() {\n    for (const atom of this.atoms) {\n      if (this.totalBonds(atom) < atom.requiredBonds) {\n        return atom;\n      }\n    }\n  }\n\n  merge(other: Molecule): Molecule {\n    this.atoms = this.atoms.concat(other.atoms);\n    this.bonds = this.bonds.concat(other.bonds);\n\n    for (const atom of other.atoms) {\n      this.bondMap.set(atom, []);\n    }\n    for (const bond of other.bonds) {\n      this.bondMap.get(bond.atom1).push(bond);\n      this.bondMap.get(bond.atom2).push(bond);\n    }\n\n    return this;\n  }\n\n  private static parseFormulaParts(formula: string) {\n    interface State {\n      parts: FormulaParts;\n      currentPart: string;\n    }\n\n    let state: State = {\n      parts: [],\n      currentPart: '',\n    };\n    const stack: State[] = [];\n    for (let i = 0; i < formula.length; ) {\n      const c = formula[i++];\n      switch (c) {\n        case '(':\n          state.parts.push(state.currentPart);\n          state.currentPart = '';\n\n          stack.push(state);\n          state = {\n            parts: [],\n            currentPart: '',\n          };\n          break;\n        case ')':\n          state.parts.push(state.currentPart);\n\n          const oldState = state;\n          state = stack.pop();\n          state.parts.push(oldState.parts);\n          break;\n        default:\n          state.currentPart += c;\n          break;\n      }\n    }\n\n    if (stack.length > 0) {\n      throw new Error('');\n    }\n    state.parts.push(state.currentPart);\n    return state.parts;\n  }\n\n  private static parseFormula(formula: string) {\n    const atoms: string[] = [];\n    for (let i = 0; i < formula.length; ) {\n      let symbol = formula[i++];\n      let countStr = '';\n      while (i < formula.length && isLower(formula[i])) {\n        symbol += formula[i++];\n      }\n      while (i < formula.length && isNumeric(formula[i])) {\n        countStr += formula[i++];\n      }\n\n      const count = +countStr || 1;\n      for (let j = 0; j < count; j++) {\n        atoms.push(symbol);\n      }\n    }\n    return atoms;\n  }\n\n  log() {\n    console.group('ATOMS:');\n    console.table(this.atoms);\n    console.groupEnd();\n\n    console.group('BONDS:');\n    console.table(this.bonds);\n    console.groupEnd();\n  }\n\n  draw(canvas: Canvas) {\n    for (const bond of this.bonds) {\n      bond.draw(canvas);\n    }\n    for (const atom of this.atoms) {\n      atom.draw(canvas);\n    }\n  }\n\n  addAtom(atom: Atom) {\n    this.atoms.push(atom);\n    this.bondMap.set(atom, []);\n  }\n\n  bond(atom1: Atom, atom2: Atom, count: number = 1) {\n    const existingBond = this.findBond(atom1, atom2);\n    if (existingBond) {\n      existingBond.count += count;\n      return;\n    }\n\n    const bondLength =\n      atom1.symbol === 'H' || atom2.symbol === 'H'\n        ? hydrogenBondLength\n        : normalBondLength;\n    atom2.position = this.getNextBondingPosition(atom1, bondLength);\n\n    const bond = new Bond(atom1, atom2, count);\n    this.bonds.push(bond);\n\n    this.bondMap.get(atom1).push(bond);\n    this.bondMap.get(atom2).push(bond);\n  }\n\n  findBond(atom1: Atom, atom2: Atom) {\n    const bondList = this.bondMap.get(atom1);\n    return bondList.find(\n      (bond) => bond.atom1 === atom2 || bond.atom2 === atom2\n    );\n  }\n\n  getNextBondingPosition(atom: Atom, bondLength: number): [number, number] {\n    const bonds = this.bondMap.get(atom);\n    const bondedTo: Atom[] = [];\n    for (const bond of bonds) {\n      if (bond.atom1 !== atom) {\n        bondedTo.push(bond.atom1);\n      }\n      if (bond.atom2 !== atom) {\n        bondedTo.push(bond.atom2);\n      }\n    }\n\n    const [x, y] = atom.position;\n    if (!bondedTo.some((a) => rightOf(atom.position, a.position)))\n      return [x + bondLength, y];\n    if (!bondedTo.some((a) => leftOf(atom.position, a.position)))\n      return [x - bondLength, y];\n    if (!bondedTo.some((a) => below(atom.position, a.position)))\n      return [x, y + bondLength];\n    if (!bondedTo.some((a) => above(atom.position, a.position)))\n      return [x, y - bondLength];\n    throw new Error('Trying to over-bond atom');\n  }\n\n  autoBond() {\n    // DESC atomic number\n    this.atoms.sort((a, b) => b.atomicNumber - a.atomicNumber);\n    // DESC required bonds\n    this.atoms.sort((a, b) => b.requiredBonds - a.requiredBonds);\n\n    const centerAtom = this.atoms[0];\n    const otherAtoms = this.atoms.slice(1);\n    for (const atom of otherAtoms) {\n      this.bond(centerAtom, atom);\n    }\n\n    this.addExtraBonds();\n\n    // For edge cases like SO2\n    for (let i = 0; !this.hasRequiredBonds; i++) {\n      if (i > 100) {\n        throw new Error('Auto bonding taking too long');\n      }\n\n      for (const atom of otherAtoms) {\n        if (atom.requiredBonds > this.totalBonds(atom)) {\n          this.bond(centerAtom, atom);\n          break;\n        }\n      }\n    }\n  }\n\n  get hasRequiredBonds() {\n    let extraBondsNeeded = 0;\n    for (const atom of this.atoms) {\n      const totalBonds = this.totalBonds(atom);\n      if (totalBonds !== atom.requiredBonds) {\n        if (totalBonds > atom.requiredBonds) {\n          console.warn(`${atom.symbol} atom is over-bonded`);\n        }\n        extraBondsNeeded += atom.requiredBonds - totalBonds;\n      }\n    }\n    return extraBondsNeeded === 0;\n  }\n\n  addExtraBonds() {\n    for (let i = 0; !this.hasRequiredBonds; i++) {\n      if (i > 10) {\n        console.warn('Auto bonding taking too long, skipping');\n        return;\n      }\n\n      for (const bond of this.bonds) {\n        if (\n          this.totalBonds(bond.atom1) < bond.atom1.requiredBonds &&\n          this.totalBonds(bond.atom2) < bond.atom2.requiredBonds\n        ) {\n          this.bond(bond.atom1, bond.atom2);\n          break;\n        }\n      }\n    }\n  }\n\n  private totalBonds(atom: Atom) {\n    const bondList = this.bondMap.get(atom);\n    const totalBonds = bondList.reduce((acc, bond) => acc + bond.count, 0);\n    return totalBonds;\n  }\n\n  center(center?: [number, number]): [number, number] {\n    const cx =\n      this.atoms.reduce((acc, atom) => acc + atom.position[0], 0) /\n      this.atoms.length;\n    const cy =\n      this.atoms.reduce((acc, atom) => acc + atom.position[1], 0) /\n      this.atoms.length;\n    if (!center) {\n      return [cx, cy];\n    }\n\n    const dx = center[0] - cx;\n    const dy = center[1] - cy;\n    for (const atom of this.atoms) {\n      atom.position[0] += dx;\n      atom.position[1] += dy;\n    }\n    return center;\n  }\n}\n\nfunction isLower(c: string) {\n  return c === c.toLowerCase() && c !== c.toUpperCase();\n}\n\nfunction isNumeric(c: string) {\n  return '1234567890'.includes(c);\n}\n","import { addV, dist, normV, scaleV, subV } from \"./math\";\nimport { Molecule } from \"./molecule\";\n\nconst bondRestingLength = 50;\n\n// These are calculated differently\nconst repulsiveForce = 500;\nconst bondLengthForce = 0.2;\n\nexport function simulate(molecule: Molecule, dt: number) {\n  for (const atom1 of molecule.atoms) {\n    for (const atom2 of molecule.atoms) {\n      if (atom1 === atom2) {\n        continue;\n      }\n\n      const d = dist(atom1.position, atom2.position);\n      const n = normV(subV(atom1.position, atom2.position));\n      const vel = scaleV(repulsiveForce / (d * d), n);\n      atom1.position = addV(atom1.position, vel);\n    }\n  }\n\n  for (const atom1 of molecule.atoms) {\n    for (const atom2 of molecule.atoms) {\n      if (atom1 === atom2) {\n        continue;\n      }\n      const bond = molecule.findBond(atom1, atom2);\n      if (!bond) {\n        continue;\n      }\n\n      const d = dist(atom1.position, atom2.position);\n      const n = normV(subV(atom1.position, atom2.position));\n      const vel = scaleV(bondLengthForce * (bondRestingLength - d), n);\n      atom1.position = addV(atom1.position, vel);\n    }\n  }\n}\n","import { Canvas } from './canvas';\nimport { Molecule } from './molecule';\nimport { simulate } from './simulate';\n\nconst canvas = new Canvas('main-canvas');\n\nlet molecule = Molecule.fromStructuralFormula('CH3C(CH2CH3)CHCHCOHO', canvas.center);\n\ncanvas.animate((dt) => {\n  simulate(molecule, dt);\n  molecule.center(canvas.center);\n  molecule.draw(canvas);\n});\n\nfor (const form of document.forms) {\n  form.addEventListener('submit', (ev) => {\n    ev.preventDefault();\n    \n    const formula: HTMLInputElement = form.elements['formula'];\n    const type: HTMLInputElement = form.elements['type'];\n\n    molecule = Molecule[`from${type.value}Formula`](formula.value, canvas.center);\n\n    console.groupCollapsed(formula.value);\n    molecule.log();\n    console.groupEnd();\n  });\n}\n"]}